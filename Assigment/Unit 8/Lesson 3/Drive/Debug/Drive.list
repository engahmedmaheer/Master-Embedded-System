
Drive.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000ab8  08000130  08000130  00010130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000002c  08000be8  08000be8  00010be8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08000c14  08000c14  00020028  2**0
                  CONTENTS
  4 .ARM          00000000  08000c14  08000c14  00020028  2**0
                  CONTENTS
  5 .preinit_array 00000000  08000c14  08000c14  00020028  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08000c14  08000c14  00010c14  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08000c18  08000c18  00010c18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000028  20000000  08000c1c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000060  20000028  08000c44  00020028  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000088  08000c44  00020088  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00020028  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00020051  2**0
                  CONTENTS, READONLY
 13 .debug_info   00002694  00000000  00000000  00020094  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 0000084e  00000000  00000000  00022728  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    00000ac8  00000000  00000000  00022f76  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000001c0  00000000  00000000  00023a40  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00000168  00000000  00000000  00023c00  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00000dd8  00000000  00000000  00023d68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   000027f3  00000000  00000000  00024b40  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000092be  00000000  00000000  00027333  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_frame  00000598  00000000  00000000  000305f4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000130 <__do_global_dtors_aux>:
 8000130:	b510      	push	{r4, lr}
 8000132:	4c05      	ldr	r4, [pc, #20]	; (8000148 <__do_global_dtors_aux+0x18>)
 8000134:	7823      	ldrb	r3, [r4, #0]
 8000136:	b933      	cbnz	r3, 8000146 <__do_global_dtors_aux+0x16>
 8000138:	4b04      	ldr	r3, [pc, #16]	; (800014c <__do_global_dtors_aux+0x1c>)
 800013a:	b113      	cbz	r3, 8000142 <__do_global_dtors_aux+0x12>
 800013c:	4804      	ldr	r0, [pc, #16]	; (8000150 <__do_global_dtors_aux+0x20>)
 800013e:	f3af 8000 	nop.w
 8000142:	2301      	movs	r3, #1
 8000144:	7023      	strb	r3, [r4, #0]
 8000146:	bd10      	pop	{r4, pc}
 8000148:	20000028 	.word	0x20000028
 800014c:	00000000 	.word	0x00000000
 8000150:	08000bd0 	.word	0x08000bd0

08000154 <frame_dummy>:
 8000154:	b508      	push	{r3, lr}
 8000156:	4b03      	ldr	r3, [pc, #12]	; (8000164 <frame_dummy+0x10>)
 8000158:	b11b      	cbz	r3, 8000162 <frame_dummy+0xe>
 800015a:	4903      	ldr	r1, [pc, #12]	; (8000168 <frame_dummy+0x14>)
 800015c:	4803      	ldr	r0, [pc, #12]	; (800016c <frame_dummy+0x18>)
 800015e:	f3af 8000 	nop.w
 8000162:	bd08      	pop	{r3, pc}
 8000164:	00000000 	.word	0x00000000
 8000168:	2000002c 	.word	0x2000002c
 800016c:	08000bd0 	.word	0x08000bd0

08000170 <EXTI0_IRQHandler>:

	return LocalErrorState;
}

void EXTI0_IRQHandler()
{
 8000170:	b580      	push	{r7, lr}
 8000172:	af00      	add	r7, sp, #0

	/*Clear pending flag*/
	SET_BIT(EXTI->PR,EXTI_IRQ0);
 8000174:	4b05      	ldr	r3, [pc, #20]	; (800018c <EXTI0_IRQHandler+0x1c>)
 8000176:	695b      	ldr	r3, [r3, #20]
 8000178:	4a04      	ldr	r2, [pc, #16]	; (800018c <EXTI0_IRQHandler+0x1c>)
 800017a:	f043 0301 	orr.w	r3, r3, #1
 800017e:	6153      	str	r3, [r2, #20]
	/*CALLING IRQ Handler*/
	EXTI_pvCallBackFunc[EXTI_IRQ0]();
 8000180:	4b03      	ldr	r3, [pc, #12]	; (8000190 <EXTI0_IRQHandler+0x20>)
 8000182:	681b      	ldr	r3, [r3, #0]
 8000184:	4798      	blx	r3

}
 8000186:	bf00      	nop
 8000188:	bd80      	pop	{r7, pc}
 800018a:	bf00      	nop
 800018c:	40010400 	.word	0x40010400
 8000190:	20000044 	.word	0x20000044

08000194 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler()
{
 8000194:	b580      	push	{r7, lr}
 8000196:	af00      	add	r7, sp, #0
	/*Clear pending flag*/
	SET_BIT(EXTI->PR,EXTI_IRQ1);
 8000198:	4b05      	ldr	r3, [pc, #20]	; (80001b0 <EXTI1_IRQHandler+0x1c>)
 800019a:	695b      	ldr	r3, [r3, #20]
 800019c:	4a04      	ldr	r2, [pc, #16]	; (80001b0 <EXTI1_IRQHandler+0x1c>)
 800019e:	f043 0302 	orr.w	r3, r3, #2
 80001a2:	6153      	str	r3, [r2, #20]
	/*CALLING IRQ Handler*/
	EXTI_pvCallBackFunc[EXTI_IRQ1]();
 80001a4:	4b03      	ldr	r3, [pc, #12]	; (80001b4 <EXTI1_IRQHandler+0x20>)
 80001a6:	685b      	ldr	r3, [r3, #4]
 80001a8:	4798      	blx	r3

}
 80001aa:	bf00      	nop
 80001ac:	bd80      	pop	{r7, pc}
 80001ae:	bf00      	nop
 80001b0:	40010400 	.word	0x40010400
 80001b4:	20000044 	.word	0x20000044

080001b8 <EXTI2_IRQHandler>:
void EXTI2_IRQHandler()
{
 80001b8:	b580      	push	{r7, lr}
 80001ba:	af00      	add	r7, sp, #0

	/*Clear pending flag*/
	SET_BIT(EXTI->PR,EXTI_IRQ2);
 80001bc:	4b05      	ldr	r3, [pc, #20]	; (80001d4 <EXTI2_IRQHandler+0x1c>)
 80001be:	695b      	ldr	r3, [r3, #20]
 80001c0:	4a04      	ldr	r2, [pc, #16]	; (80001d4 <EXTI2_IRQHandler+0x1c>)
 80001c2:	f043 0304 	orr.w	r3, r3, #4
 80001c6:	6153      	str	r3, [r2, #20]
	/*CALLING IRQ Handler*/
	EXTI_pvCallBackFunc[EXTI_IRQ2]();
 80001c8:	4b03      	ldr	r3, [pc, #12]	; (80001d8 <EXTI2_IRQHandler+0x20>)
 80001ca:	689b      	ldr	r3, [r3, #8]
 80001cc:	4798      	blx	r3

}
 80001ce:	bf00      	nop
 80001d0:	bd80      	pop	{r7, pc}
 80001d2:	bf00      	nop
 80001d4:	40010400 	.word	0x40010400
 80001d8:	20000044 	.word	0x20000044

080001dc <EXTI3_IRQHandler>:
void EXTI3_IRQHandler()
{
 80001dc:	b580      	push	{r7, lr}
 80001de:	af00      	add	r7, sp, #0

	/*Clear pending flag*/
	SET_BIT(EXTI->PR,EXTI_IRQ3);
 80001e0:	4b05      	ldr	r3, [pc, #20]	; (80001f8 <EXTI3_IRQHandler+0x1c>)
 80001e2:	695b      	ldr	r3, [r3, #20]
 80001e4:	4a04      	ldr	r2, [pc, #16]	; (80001f8 <EXTI3_IRQHandler+0x1c>)
 80001e6:	f043 0308 	orr.w	r3, r3, #8
 80001ea:	6153      	str	r3, [r2, #20]
	/*CALLING IRQ Handler*/
	EXTI_pvCallBackFunc[EXTI_IRQ3]();
 80001ec:	4b03      	ldr	r3, [pc, #12]	; (80001fc <EXTI3_IRQHandler+0x20>)
 80001ee:	68db      	ldr	r3, [r3, #12]
 80001f0:	4798      	blx	r3

}
 80001f2:	bf00      	nop
 80001f4:	bd80      	pop	{r7, pc}
 80001f6:	bf00      	nop
 80001f8:	40010400 	.word	0x40010400
 80001fc:	20000044 	.word	0x20000044

08000200 <EXTI9_5_IRQHandler>:
void EXTI9_5_IRQHandler()
{
 8000200:	b580      	push	{r7, lr}
 8000202:	af00      	add	r7, sp, #0

	/*Switch Flag if raised*/
	if(EXTI5_FLAG==Raised)
 8000204:	4b28      	ldr	r3, [pc, #160]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000206:	695b      	ldr	r3, [r3, #20]
 8000208:	095b      	lsrs	r3, r3, #5
 800020a:	f003 0301 	and.w	r3, r3, #1
 800020e:	2b01      	cmp	r3, #1
 8000210:	d108      	bne.n	8000224 <EXTI9_5_IRQHandler+0x24>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ5);
 8000212:	4b25      	ldr	r3, [pc, #148]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000214:	695b      	ldr	r3, [r3, #20]
 8000216:	4a24      	ldr	r2, [pc, #144]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000218:	f043 0320 	orr.w	r3, r3, #32
 800021c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ5]();
 800021e:	4b23      	ldr	r3, [pc, #140]	; (80002ac <EXTI9_5_IRQHandler+0xac>)
 8000220:	695b      	ldr	r3, [r3, #20]
 8000222:	4798      	blx	r3
	}
	if(EXTI6_FLAG==Raised)
 8000224:	4b20      	ldr	r3, [pc, #128]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000226:	695b      	ldr	r3, [r3, #20]
 8000228:	099b      	lsrs	r3, r3, #6
 800022a:	f003 0301 	and.w	r3, r3, #1
 800022e:	2b01      	cmp	r3, #1
 8000230:	d108      	bne.n	8000244 <EXTI9_5_IRQHandler+0x44>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ6);
 8000232:	4b1d      	ldr	r3, [pc, #116]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000234:	695b      	ldr	r3, [r3, #20]
 8000236:	4a1c      	ldr	r2, [pc, #112]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000238:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800023c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ6]();
 800023e:	4b1b      	ldr	r3, [pc, #108]	; (80002ac <EXTI9_5_IRQHandler+0xac>)
 8000240:	699b      	ldr	r3, [r3, #24]
 8000242:	4798      	blx	r3
	}
	if(EXTI7_FLAG==Raised)
 8000244:	4b18      	ldr	r3, [pc, #96]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000246:	695b      	ldr	r3, [r3, #20]
 8000248:	09db      	lsrs	r3, r3, #7
 800024a:	f003 0301 	and.w	r3, r3, #1
 800024e:	2b01      	cmp	r3, #1
 8000250:	d108      	bne.n	8000264 <EXTI9_5_IRQHandler+0x64>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ7);
 8000252:	4b15      	ldr	r3, [pc, #84]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000254:	695b      	ldr	r3, [r3, #20]
 8000256:	4a14      	ldr	r2, [pc, #80]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000258:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800025c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ7]();
 800025e:	4b13      	ldr	r3, [pc, #76]	; (80002ac <EXTI9_5_IRQHandler+0xac>)
 8000260:	69db      	ldr	r3, [r3, #28]
 8000262:	4798      	blx	r3
	}
	if(EXTI8_FLAG==Raised)
 8000264:	4b10      	ldr	r3, [pc, #64]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000266:	695b      	ldr	r3, [r3, #20]
 8000268:	0a1b      	lsrs	r3, r3, #8
 800026a:	f003 0301 	and.w	r3, r3, #1
 800026e:	2b01      	cmp	r3, #1
 8000270:	d108      	bne.n	8000284 <EXTI9_5_IRQHandler+0x84>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ8);
 8000272:	4b0d      	ldr	r3, [pc, #52]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000274:	695b      	ldr	r3, [r3, #20]
 8000276:	4a0c      	ldr	r2, [pc, #48]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000278:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800027c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ8]();
 800027e:	4b0b      	ldr	r3, [pc, #44]	; (80002ac <EXTI9_5_IRQHandler+0xac>)
 8000280:	6a1b      	ldr	r3, [r3, #32]
 8000282:	4798      	blx	r3
	}
	if(EXTI9_FLAG==Raised)
 8000284:	4b08      	ldr	r3, [pc, #32]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000286:	695b      	ldr	r3, [r3, #20]
 8000288:	0a5b      	lsrs	r3, r3, #9
 800028a:	f003 0301 	and.w	r3, r3, #1
 800028e:	2b01      	cmp	r3, #1
 8000290:	d108      	bne.n	80002a4 <EXTI9_5_IRQHandler+0xa4>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ9);
 8000292:	4b05      	ldr	r3, [pc, #20]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000294:	695b      	ldr	r3, [r3, #20]
 8000296:	4a04      	ldr	r2, [pc, #16]	; (80002a8 <EXTI9_5_IRQHandler+0xa8>)
 8000298:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800029c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ9]();
 800029e:	4b03      	ldr	r3, [pc, #12]	; (80002ac <EXTI9_5_IRQHandler+0xac>)
 80002a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80002a2:	4798      	blx	r3
	else
	{
		//error
	}

}
 80002a4:	bf00      	nop
 80002a6:	bd80      	pop	{r7, pc}
 80002a8:	40010400 	.word	0x40010400
 80002ac:	20000044 	.word	0x20000044

080002b0 <EXTI15_10_IRQHandler>:
void EXTI15_10_IRQHandler()
{
 80002b0:	b580      	push	{r7, lr}
 80002b2:	af00      	add	r7, sp, #0
	/*Switch Flag if raised*/
	if(EXTI10_FLAG==Raised)
 80002b4:	4b30      	ldr	r3, [pc, #192]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 80002b6:	695b      	ldr	r3, [r3, #20]
 80002b8:	0a9b      	lsrs	r3, r3, #10
 80002ba:	f003 0301 	and.w	r3, r3, #1
 80002be:	2b01      	cmp	r3, #1
 80002c0:	d108      	bne.n	80002d4 <EXTI15_10_IRQHandler+0x24>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ10);
 80002c2:	4b2d      	ldr	r3, [pc, #180]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 80002c4:	695b      	ldr	r3, [r3, #20]
 80002c6:	4a2c      	ldr	r2, [pc, #176]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 80002c8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80002cc:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/


		EXTI_pvCallBackFunc[EXTI_IRQ10]();
 80002ce:	4b2b      	ldr	r3, [pc, #172]	; (800037c <EXTI15_10_IRQHandler+0xcc>)
 80002d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80002d2:	4798      	blx	r3
	}
	if(EXTI11_FLAG==Raised)
 80002d4:	4b28      	ldr	r3, [pc, #160]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 80002d6:	695b      	ldr	r3, [r3, #20]
 80002d8:	0adb      	lsrs	r3, r3, #11
 80002da:	f003 0301 	and.w	r3, r3, #1
 80002de:	2b01      	cmp	r3, #1
 80002e0:	d108      	bne.n	80002f4 <EXTI15_10_IRQHandler+0x44>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ11);
 80002e2:	4b25      	ldr	r3, [pc, #148]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 80002e4:	695b      	ldr	r3, [r3, #20]
 80002e6:	4a24      	ldr	r2, [pc, #144]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 80002e8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80002ec:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ11]();
 80002ee:	4b23      	ldr	r3, [pc, #140]	; (800037c <EXTI15_10_IRQHandler+0xcc>)
 80002f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80002f2:	4798      	blx	r3
	}
	if(EXTI12_FLAG==Raised)
 80002f4:	4b20      	ldr	r3, [pc, #128]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 80002f6:	695b      	ldr	r3, [r3, #20]
 80002f8:	0b1b      	lsrs	r3, r3, #12
 80002fa:	f003 0301 	and.w	r3, r3, #1
 80002fe:	2b01      	cmp	r3, #1
 8000300:	d108      	bne.n	8000314 <EXTI15_10_IRQHandler+0x64>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ12);
 8000302:	4b1d      	ldr	r3, [pc, #116]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000304:	695b      	ldr	r3, [r3, #20]
 8000306:	4a1c      	ldr	r2, [pc, #112]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000308:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800030c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ12]();
 800030e:	4b1b      	ldr	r3, [pc, #108]	; (800037c <EXTI15_10_IRQHandler+0xcc>)
 8000310:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000312:	4798      	blx	r3
	}
	if(EXTI13_FLAG==Raised)
 8000314:	4b18      	ldr	r3, [pc, #96]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000316:	695b      	ldr	r3, [r3, #20]
 8000318:	0b5b      	lsrs	r3, r3, #13
 800031a:	f003 0301 	and.w	r3, r3, #1
 800031e:	2b01      	cmp	r3, #1
 8000320:	d108      	bne.n	8000334 <EXTI15_10_IRQHandler+0x84>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ13);
 8000322:	4b15      	ldr	r3, [pc, #84]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000324:	695b      	ldr	r3, [r3, #20]
 8000326:	4a14      	ldr	r2, [pc, #80]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000328:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800032c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ13]();
 800032e:	4b13      	ldr	r3, [pc, #76]	; (800037c <EXTI15_10_IRQHandler+0xcc>)
 8000330:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000332:	4798      	blx	r3
	}
	if(EXTI14_FLAG==Raised)
 8000334:	4b10      	ldr	r3, [pc, #64]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000336:	695b      	ldr	r3, [r3, #20]
 8000338:	0b9b      	lsrs	r3, r3, #14
 800033a:	f003 0301 	and.w	r3, r3, #1
 800033e:	2b01      	cmp	r3, #1
 8000340:	d108      	bne.n	8000354 <EXTI15_10_IRQHandler+0xa4>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ14);
 8000342:	4b0d      	ldr	r3, [pc, #52]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000344:	695b      	ldr	r3, [r3, #20]
 8000346:	4a0c      	ldr	r2, [pc, #48]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000348:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800034c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ14]();
 800034e:	4b0b      	ldr	r3, [pc, #44]	; (800037c <EXTI15_10_IRQHandler+0xcc>)
 8000350:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000352:	4798      	blx	r3
	}
	if(EXTI15_FLAG==Raised)
 8000354:	4b08      	ldr	r3, [pc, #32]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000356:	695b      	ldr	r3, [r3, #20]
 8000358:	0bdb      	lsrs	r3, r3, #15
 800035a:	f003 0301 	and.w	r3, r3, #1
 800035e:	2b01      	cmp	r3, #1
 8000360:	d108      	bne.n	8000374 <EXTI15_10_IRQHandler+0xc4>
	{
		/*Clear pending flag*/
		SET_BIT(EXTI->PR,EXTI_IRQ15);
 8000362:	4b05      	ldr	r3, [pc, #20]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000364:	695b      	ldr	r3, [r3, #20]
 8000366:	4a04      	ldr	r2, [pc, #16]	; (8000378 <EXTI15_10_IRQHandler+0xc8>)
 8000368:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800036c:	6153      	str	r3, [r2, #20]
		/*CALLING IRQ Handler*/
		EXTI_pvCallBackFunc[EXTI_IRQ15]();
 800036e:	4b03      	ldr	r3, [pc, #12]	; (800037c <EXTI15_10_IRQHandler+0xcc>)
 8000370:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000372:	4798      	blx	r3
	}
	else
	{
		//error
	}
}
 8000374:	bf00      	nop
 8000376:	bd80      	pop	{r7, pc}
 8000378:	40010400 	.word	0x40010400
 800037c:	20000044 	.word	0x20000044

08000380 <GET_CRLH_Position>:
/*For peripheral Only :*/

static GPIO_TypeDef_S* GPIOPORT[GPIO_PERIPHERAL_NUM] ={GPIOA,GPIOB,GPIOC,GPIOD,GPIOE};

static uint8_t GET_CRLH_Position(GPIO_PIN_E PINNUM)
{
 8000380:	b480      	push	{r7}
 8000382:	b085      	sub	sp, #20
 8000384:	af00      	add	r7, sp, #0
 8000386:	4603      	mov	r3, r0
 8000388:	80fb      	strh	r3, [r7, #6]
	uint8_t Position =0;
 800038a:	2300      	movs	r3, #0
 800038c:	73fb      	strb	r3, [r7, #15]

	switch(PINNUM)
 800038e:	88fb      	ldrh	r3, [r7, #6]
 8000390:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8000394:	f000 80b8 	beq.w	8000508 <GET_CRLH_Position+0x188>
 8000398:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800039c:	f300 80b7 	bgt.w	800050e <GET_CRLH_Position+0x18e>
 80003a0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80003a4:	f000 80ad 	beq.w	8000502 <GET_CRLH_Position+0x182>
 80003a8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80003ac:	f300 80af 	bgt.w	800050e <GET_CRLH_Position+0x18e>
 80003b0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80003b4:	f000 80a2 	beq.w	80004fc <GET_CRLH_Position+0x17c>
 80003b8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80003bc:	f300 80a7 	bgt.w	800050e <GET_CRLH_Position+0x18e>
 80003c0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80003c4:	f000 8097 	beq.w	80004f6 <GET_CRLH_Position+0x176>
 80003c8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80003cc:	f300 809f 	bgt.w	800050e <GET_CRLH_Position+0x18e>
 80003d0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80003d4:	f000 808c 	beq.w	80004f0 <GET_CRLH_Position+0x170>
 80003d8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80003dc:	f300 8097 	bgt.w	800050e <GET_CRLH_Position+0x18e>
 80003e0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80003e4:	f000 8081 	beq.w	80004ea <GET_CRLH_Position+0x16a>
 80003e8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80003ec:	f300 808f 	bgt.w	800050e <GET_CRLH_Position+0x18e>
 80003f0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80003f4:	d076      	beq.n	80004e4 <GET_CRLH_Position+0x164>
 80003f6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80003fa:	f300 8088 	bgt.w	800050e <GET_CRLH_Position+0x18e>
 80003fe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000402:	d06c      	beq.n	80004de <GET_CRLH_Position+0x15e>
 8000404:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000408:	f300 8081 	bgt.w	800050e <GET_CRLH_Position+0x18e>
 800040c:	2b80      	cmp	r3, #128	; 0x80
 800040e:	d063      	beq.n	80004d8 <GET_CRLH_Position+0x158>
 8000410:	2b80      	cmp	r3, #128	; 0x80
 8000412:	dc7c      	bgt.n	800050e <GET_CRLH_Position+0x18e>
 8000414:	2b20      	cmp	r3, #32
 8000416:	dc47      	bgt.n	80004a8 <GET_CRLH_Position+0x128>
 8000418:	2b00      	cmp	r3, #0
 800041a:	dd78      	ble.n	800050e <GET_CRLH_Position+0x18e>
 800041c:	3b01      	subs	r3, #1
 800041e:	2b1f      	cmp	r3, #31
 8000420:	d875      	bhi.n	800050e <GET_CRLH_Position+0x18e>
 8000422:	a201      	add	r2, pc, #4	; (adr r2, 8000428 <GET_CRLH_Position+0xa8>)
 8000424:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000428:	080004af 	.word	0x080004af
 800042c:	080004b5 	.word	0x080004b5
 8000430:	0800050f 	.word	0x0800050f
 8000434:	080004bb 	.word	0x080004bb
 8000438:	0800050f 	.word	0x0800050f
 800043c:	0800050f 	.word	0x0800050f
 8000440:	0800050f 	.word	0x0800050f
 8000444:	080004c1 	.word	0x080004c1
 8000448:	0800050f 	.word	0x0800050f
 800044c:	0800050f 	.word	0x0800050f
 8000450:	0800050f 	.word	0x0800050f
 8000454:	0800050f 	.word	0x0800050f
 8000458:	0800050f 	.word	0x0800050f
 800045c:	0800050f 	.word	0x0800050f
 8000460:	0800050f 	.word	0x0800050f
 8000464:	080004c7 	.word	0x080004c7
 8000468:	0800050f 	.word	0x0800050f
 800046c:	0800050f 	.word	0x0800050f
 8000470:	0800050f 	.word	0x0800050f
 8000474:	0800050f 	.word	0x0800050f
 8000478:	0800050f 	.word	0x0800050f
 800047c:	0800050f 	.word	0x0800050f
 8000480:	0800050f 	.word	0x0800050f
 8000484:	0800050f 	.word	0x0800050f
 8000488:	0800050f 	.word	0x0800050f
 800048c:	0800050f 	.word	0x0800050f
 8000490:	0800050f 	.word	0x0800050f
 8000494:	0800050f 	.word	0x0800050f
 8000498:	0800050f 	.word	0x0800050f
 800049c:	0800050f 	.word	0x0800050f
 80004a0:	0800050f 	.word	0x0800050f
 80004a4:	080004cd 	.word	0x080004cd
 80004a8:	2b40      	cmp	r3, #64	; 0x40
 80004aa:	d012      	beq.n	80004d2 <GET_CRLH_Position+0x152>
 80004ac:	e02f      	b.n	800050e <GET_CRLH_Position+0x18e>
	{
	case PIN0  :Position=0   ; break;
 80004ae:	2300      	movs	r3, #0
 80004b0:	73fb      	strb	r3, [r7, #15]
 80004b2:	e02c      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN1  :Position=4   ; break;
 80004b4:	2304      	movs	r3, #4
 80004b6:	73fb      	strb	r3, [r7, #15]
 80004b8:	e029      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN2  :Position=8   ; break;
 80004ba:	2308      	movs	r3, #8
 80004bc:	73fb      	strb	r3, [r7, #15]
 80004be:	e026      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN3  :Position=12  ; break;
 80004c0:	230c      	movs	r3, #12
 80004c2:	73fb      	strb	r3, [r7, #15]
 80004c4:	e023      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN4  :Position=16  ; break;
 80004c6:	2310      	movs	r3, #16
 80004c8:	73fb      	strb	r3, [r7, #15]
 80004ca:	e020      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN5  :Position=20  ; break;
 80004cc:	2314      	movs	r3, #20
 80004ce:	73fb      	strb	r3, [r7, #15]
 80004d0:	e01d      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN6  :Position=24  ; break;
 80004d2:	2318      	movs	r3, #24
 80004d4:	73fb      	strb	r3, [r7, #15]
 80004d6:	e01a      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN7  :Position=28  ; break;
 80004d8:	231c      	movs	r3, #28
 80004da:	73fb      	strb	r3, [r7, #15]
 80004dc:	e017      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN8  :Position=0   ; break;
 80004de:	2300      	movs	r3, #0
 80004e0:	73fb      	strb	r3, [r7, #15]
 80004e2:	e014      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN9  :Position=4   ; break;
 80004e4:	2304      	movs	r3, #4
 80004e6:	73fb      	strb	r3, [r7, #15]
 80004e8:	e011      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN10 :Position=8   ; break;
 80004ea:	2308      	movs	r3, #8
 80004ec:	73fb      	strb	r3, [r7, #15]
 80004ee:	e00e      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN11 :Position=12  ; break;
 80004f0:	230c      	movs	r3, #12
 80004f2:	73fb      	strb	r3, [r7, #15]
 80004f4:	e00b      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN12 :Position=16  ; break;
 80004f6:	2310      	movs	r3, #16
 80004f8:	73fb      	strb	r3, [r7, #15]
 80004fa:	e008      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN13 :Position=20  ; break;
 80004fc:	2314      	movs	r3, #20
 80004fe:	73fb      	strb	r3, [r7, #15]
 8000500:	e005      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN14 :Position=24  ; break;
 8000502:	2318      	movs	r3, #24
 8000504:	73fb      	strb	r3, [r7, #15]
 8000506:	e002      	b.n	800050e <GET_CRLH_Position+0x18e>
	case PIN15 :Position=28  ; break;
 8000508:	231c      	movs	r3, #28
 800050a:	73fb      	strb	r3, [r7, #15]
 800050c:	bf00      	nop
	}

	return Position;
 800050e:	7bfb      	ldrb	r3, [r7, #15]

}
 8000510:	4618      	mov	r0, r3
 8000512:	3714      	adds	r7, #20
 8000514:	46bd      	mov	sp, r7
 8000516:	bc80      	pop	{r7}
 8000518:	4770      	bx	lr
 800051a:	bf00      	nop

0800051c <GPIO_u8PinInit>:
 *
 * Return:	ErrorState , Type:uint8_t
 *
 ******************************************************************************/
uint8_t GPIO_u8PinInit(const GPIO_PinConfig_S* PinConfig)
{
 800051c:	b590      	push	{r4, r7, lr}
 800051e:	b087      	sub	sp, #28
 8000520:	af00      	add	r7, sp, #0
 8000522:	6078      	str	r0, [r7, #4]
	uint8_t LocalErrorStatue=OK ;
 8000524:	2300      	movs	r3, #0
 8000526:	75fb      	strb	r3, [r7, #23]
	//Port configuration register low (GPIOx_CRL) config pins 0 -> 7
	//Port configuration register high (GPIOx_CRH)  config pins 8 -> 15
	volatile uint32_t* configReg = NULL ;
 8000528:	2300      	movs	r3, #0
 800052a:	613b      	str	r3, [r7, #16]
	volatile uint8_t PIN = 0;
 800052c:	2300      	movs	r3, #0
 800052e:	73fb      	strb	r3, [r7, #15]
	configReg = (PinConfig->PinNumber < PIN8) ? &GPIOPORT[PinConfig->PortNum] ->CRL  : &GPIOPORT[PinConfig->PortNum] ->CRH  ;
 8000530:	687b      	ldr	r3, [r7, #4]
 8000532:	885b      	ldrh	r3, [r3, #2]
 8000534:	2bff      	cmp	r3, #255	; 0xff
 8000536:	d806      	bhi.n	8000546 <GPIO_u8PinInit+0x2a>
 8000538:	687b      	ldr	r3, [r7, #4]
 800053a:	881b      	ldrh	r3, [r3, #0]
 800053c:	461a      	mov	r2, r3
 800053e:	4b4f      	ldr	r3, [pc, #316]	; (800067c <GPIO_u8PinInit+0x160>)
 8000540:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000544:	e006      	b.n	8000554 <GPIO_u8PinInit+0x38>
 8000546:	687b      	ldr	r3, [r7, #4]
 8000548:	881b      	ldrh	r3, [r3, #0]
 800054a:	461a      	mov	r2, r3
 800054c:	4b4b      	ldr	r3, [pc, #300]	; (800067c <GPIO_u8PinInit+0x160>)
 800054e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000552:	3304      	adds	r3, #4
 8000554:	613b      	str	r3, [r7, #16]

	// clear CNF[1:0] & MODE[1:0]
	(*configReg) &= ~(0xF << GET_CRLH_Position(PinConfig->PinNumber));
 8000556:	687b      	ldr	r3, [r7, #4]
 8000558:	885b      	ldrh	r3, [r3, #2]
 800055a:	4618      	mov	r0, r3
 800055c:	f7ff ff10 	bl	8000380 <GET_CRLH_Position>
 8000560:	4603      	mov	r3, r0
 8000562:	461a      	mov	r2, r3
 8000564:	230f      	movs	r3, #15
 8000566:	4093      	lsls	r3, r2
 8000568:	43da      	mvns	r2, r3
 800056a:	693b      	ldr	r3, [r7, #16]
 800056c:	681b      	ldr	r3, [r3, #0]
 800056e:	401a      	ands	r2, r3
 8000570:	693b      	ldr	r3, [r7, #16]
 8000572:	601a      	str	r2, [r3, #0]

	//if pin is OUTPUT
	if (PinConfig->Mode == GPIO_Output_PUSHPULL || PinConfig->Mode == GPIO_Output_OPENDRAIN || PinConfig->Mode == GPIO_AF_PP || PinConfig->Mode == GPIO_AF_OD)
 8000574:	687b      	ldr	r3, [r7, #4]
 8000576:	791b      	ldrb	r3, [r3, #4]
 8000578:	2b04      	cmp	r3, #4
 800057a:	d00b      	beq.n	8000594 <GPIO_u8PinInit+0x78>
 800057c:	687b      	ldr	r3, [r7, #4]
 800057e:	791b      	ldrb	r3, [r3, #4]
 8000580:	2b05      	cmp	r3, #5
 8000582:	d007      	beq.n	8000594 <GPIO_u8PinInit+0x78>
 8000584:	687b      	ldr	r3, [r7, #4]
 8000586:	791b      	ldrb	r3, [r3, #4]
 8000588:	2b06      	cmp	r3, #6
 800058a:	d003      	beq.n	8000594 <GPIO_u8PinInit+0x78>
 800058c:	687b      	ldr	r3, [r7, #4]
 800058e:	791b      	ldrb	r3, [r3, #4]
 8000590:	2b07      	cmp	r3, #7
 8000592:	d10f      	bne.n	80005b4 <GPIO_u8PinInit+0x98>
	{
		//Set CNF[1:0] & MODE[1:0]
		PIN = (((PinConfig->Mode - 4) << 2) | (PinConfig->Speed)) & 0x0F ;
 8000594:	687b      	ldr	r3, [r7, #4]
 8000596:	791b      	ldrb	r3, [r3, #4]
 8000598:	3b04      	subs	r3, #4
 800059a:	009b      	lsls	r3, r3, #2
 800059c:	b25a      	sxtb	r2, r3
 800059e:	687b      	ldr	r3, [r7, #4]
 80005a0:	795b      	ldrb	r3, [r3, #5]
 80005a2:	b25b      	sxtb	r3, r3
 80005a4:	4313      	orrs	r3, r2
 80005a6:	b25b      	sxtb	r3, r3
 80005a8:	b2db      	uxtb	r3, r3
 80005aa:	f003 030f 	and.w	r3, r3, #15
 80005ae:	b2db      	uxtb	r3, r3
 80005b0:	73fb      	strb	r3, [r7, #15]
 80005b2:	e04d      	b.n	8000650 <GPIO_u8PinInit+0x134>

	}
	//if pin is INPUT
	else //MODE = 00 input mode (reset state)
	{
		if ( (PinConfig->Mode == GPIO_INPUT_Floating) | (PinConfig->Mode == GPIO_ANALOG))
 80005b4:	687b      	ldr	r3, [r7, #4]
 80005b6:	791b      	ldrb	r3, [r3, #4]
 80005b8:	2b01      	cmp	r3, #1
 80005ba:	bf0c      	ite	eq
 80005bc:	2301      	moveq	r3, #1
 80005be:	2300      	movne	r3, #0
 80005c0:	b2da      	uxtb	r2, r3
 80005c2:	687b      	ldr	r3, [r7, #4]
 80005c4:	791b      	ldrb	r3, [r3, #4]
 80005c6:	2b00      	cmp	r3, #0
 80005c8:	bf0c      	ite	eq
 80005ca:	2301      	moveq	r3, #1
 80005cc:	2300      	movne	r3, #0
 80005ce:	b2db      	uxtb	r3, r3
 80005d0:	4313      	orrs	r3, r2
 80005d2:	b2db      	uxtb	r3, r3
 80005d4:	2b00      	cmp	r3, #0
 80005d6:	d008      	beq.n	80005ea <GPIO_u8PinInit+0xce>
		{
			PIN = (((PinConfig->Mode ) << 2) | (UNUSED)) & 0x0F ;
 80005d8:	687b      	ldr	r3, [r7, #4]
 80005da:	791b      	ldrb	r3, [r3, #4]
 80005dc:	009b      	lsls	r3, r3, #2
 80005de:	b2db      	uxtb	r3, r3
 80005e0:	f003 030f 	and.w	r3, r3, #15
 80005e4:	b2db      	uxtb	r3, r3
 80005e6:	73fb      	strb	r3, [r7, #15]
 80005e8:	e032      	b.n	8000650 <GPIO_u8PinInit+0x134>
		}
		else if (PinConfig->Mode == GPIO_INPUT_Floating)//considered as INPUT Floating
 80005ea:	687b      	ldr	r3, [r7, #4]
 80005ec:	791b      	ldrb	r3, [r3, #4]
 80005ee:	2b01      	cmp	r3, #1
 80005f0:	d102      	bne.n	80005f8 <GPIO_u8PinInit+0xdc>
		{
			PIN = (((GPIO_INPUT_Floating) << 2) | (UNUSED)) & 0x0F ;
 80005f2:	2304      	movs	r3, #4
 80005f4:	73fb      	strb	r3, [r7, #15]
 80005f6:	e02b      	b.n	8000650 <GPIO_u8PinInit+0x134>
		}
		else // PU PD INPUT
		{
			PIN = (((GPIO_INPUT_PU) << 2) | (UNUSED)) & 0x0F ;
 80005f8:	2308      	movs	r3, #8
 80005fa:	73fb      	strb	r3, [r7, #15]
			if (PinConfig->Mode == GPIO_INPUT_PU)
 80005fc:	687b      	ldr	r3, [r7, #4]
 80005fe:	791b      	ldrb	r3, [r3, #4]
 8000600:	2b02      	cmp	r3, #2
 8000602:	d112      	bne.n	800062a <GPIO_u8PinInit+0x10e>
			{
				//ODR = 1 INPUT Pull Up :Table 20. Port bit configuration table
				GPIOPORT[PinConfig->PortNum] ->ODR  |= PinConfig->PinNumber;
 8000604:	687b      	ldr	r3, [r7, #4]
 8000606:	881b      	ldrh	r3, [r3, #0]
 8000608:	461a      	mov	r2, r3
 800060a:	4b1c      	ldr	r3, [pc, #112]	; (800067c <GPIO_u8PinInit+0x160>)
 800060c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000610:	68da      	ldr	r2, [r3, #12]
 8000612:	687b      	ldr	r3, [r7, #4]
 8000614:	885b      	ldrh	r3, [r3, #2]
 8000616:	4619      	mov	r1, r3
 8000618:	687b      	ldr	r3, [r7, #4]
 800061a:	881b      	ldrh	r3, [r3, #0]
 800061c:	4618      	mov	r0, r3
 800061e:	4b17      	ldr	r3, [pc, #92]	; (800067c <GPIO_u8PinInit+0x160>)
 8000620:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8000624:	430a      	orrs	r2, r1
 8000626:	60da      	str	r2, [r3, #12]
 8000628:	e012      	b.n	8000650 <GPIO_u8PinInit+0x134>
			}else
			{
				//ODR = 0 INPUT Pull Down :Table 20. Port bit configuration table
				GPIOPORT[PinConfig->PortNum] ->ODR  &= ~(PinConfig->PinNumber);
 800062a:	687b      	ldr	r3, [r7, #4]
 800062c:	881b      	ldrh	r3, [r3, #0]
 800062e:	461a      	mov	r2, r3
 8000630:	4b12      	ldr	r3, [pc, #72]	; (800067c <GPIO_u8PinInit+0x160>)
 8000632:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000636:	68da      	ldr	r2, [r3, #12]
 8000638:	687b      	ldr	r3, [r7, #4]
 800063a:	885b      	ldrh	r3, [r3, #2]
 800063c:	43db      	mvns	r3, r3
 800063e:	4619      	mov	r1, r3
 8000640:	687b      	ldr	r3, [r7, #4]
 8000642:	881b      	ldrh	r3, [r3, #0]
 8000644:	4618      	mov	r0, r3
 8000646:	4b0d      	ldr	r3, [pc, #52]	; (800067c <GPIO_u8PinInit+0x160>)
 8000648:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800064c:	400a      	ands	r2, r1
 800064e:	60da      	str	r2, [r3, #12]
		}

	}

	//Write on CRL or CRH
	(*configReg) |= ( (PIN) << GET_CRLH_Position(PinConfig->PinNumber)) ;
 8000650:	7bfb      	ldrb	r3, [r7, #15]
 8000652:	b2db      	uxtb	r3, r3
 8000654:	461c      	mov	r4, r3
 8000656:	687b      	ldr	r3, [r7, #4]
 8000658:	885b      	ldrh	r3, [r3, #2]
 800065a:	4618      	mov	r0, r3
 800065c:	f7ff fe90 	bl	8000380 <GET_CRLH_Position>
 8000660:	4603      	mov	r3, r0
 8000662:	fa04 f203 	lsl.w	r2, r4, r3
 8000666:	693b      	ldr	r3, [r7, #16]
 8000668:	681b      	ldr	r3, [r3, #0]
 800066a:	431a      	orrs	r2, r3
 800066c:	693b      	ldr	r3, [r7, #16]
 800066e:	601a      	str	r2, [r3, #0]

	return LocalErrorStatue ;
 8000670:	7dfb      	ldrb	r3, [r7, #23]

}
 8000672:	4618      	mov	r0, r3
 8000674:	371c      	adds	r7, #28
 8000676:	46bd      	mov	sp, r7
 8000678:	bd90      	pop	{r4, r7, pc}
 800067a:	bf00      	nop
 800067c:	20000000 	.word	0x20000000

08000680 <RCC_GetSYSCLCK>:
/**
 *
 * @return : SYSTEM CLCK  Frequency
 */
uint32_t RCC_GetSYSCLCK(void)
{
 8000680:	b480      	push	{r7}
 8000682:	af00      	add	r7, sp, #0
	00: HSI oscillator used as system clock
	01: HSE oscillator used as system clock
	10: PLL used as system clock
	11: not applicable*/

	switch( (RCC->CFGR.Reg >>SWS_BIT) & SWS_MASK  )
 8000684:	4b0c      	ldr	r3, [pc, #48]	; (80006b8 <RCC_GetSYSCLCK+0x38>)
 8000686:	685b      	ldr	r3, [r3, #4]
 8000688:	089b      	lsrs	r3, r3, #2
 800068a:	f003 0303 	and.w	r3, r3, #3
 800068e:	2b02      	cmp	r3, #2
 8000690:	d00a      	beq.n	80006a8 <RCC_GetSYSCLCK+0x28>
 8000692:	2b02      	cmp	r3, #2
 8000694:	d80a      	bhi.n	80006ac <RCC_GetSYSCLCK+0x2c>
 8000696:	2b00      	cmp	r3, #0
 8000698:	d002      	beq.n	80006a0 <RCC_GetSYSCLCK+0x20>
 800069a:	2b01      	cmp	r3, #1
 800069c:	d002      	beq.n	80006a4 <RCC_GetSYSCLCK+0x24>
	{
	case HSI :  return HSI_CLCK                 ;break;
	case HSE :  return HSE_CLCK                 ;break;
	case PLL :  return PLL_CLCK                 ;break; /*16MHZ*/
	default  :  								;break;
 800069e:	e005      	b.n	80006ac <RCC_GetSYSCLCK+0x2c>
	case HSI :  return HSI_CLCK                 ;break;
 80006a0:	4b06      	ldr	r3, [pc, #24]	; (80006bc <RCC_GetSYSCLCK+0x3c>)
 80006a2:	e004      	b.n	80006ae <RCC_GetSYSCLCK+0x2e>
	case HSE :  return HSE_CLCK                 ;break;
 80006a4:	4b06      	ldr	r3, [pc, #24]	; (80006c0 <RCC_GetSYSCLCK+0x40>)
 80006a6:	e002      	b.n	80006ae <RCC_GetSYSCLCK+0x2e>
	case PLL :  return PLL_CLCK                 ;break; /*16MHZ*/
 80006a8:	2300      	movs	r3, #0
 80006aa:	e000      	b.n	80006ae <RCC_GetSYSCLCK+0x2e>
	default  :  								;break;
 80006ac:	bf00      	nop
	}




}
 80006ae:	4618      	mov	r0, r3
 80006b0:	46bd      	mov	sp, r7
 80006b2:	bc80      	pop	{r7}
 80006b4:	4770      	bx	lr
 80006b6:	bf00      	nop
 80006b8:	40021000 	.word	0x40021000
 80006bc:	007a1200 	.word	0x007a1200
 80006c0:	00f42400 	.word	0x00f42400

080006c4 <RCC_GetHCLCK>:
/**
 *
 * @return : HCLCK Frequency
 */
uint32_t RCC_GetHCLCK(void)
{
 80006c4:	b580      	push	{r7, lr}
 80006c6:	af00      	add	r7, sp, #0
	1100: SYSCLK divided by 64
	1101: SYSCLK divided by 128
	1110: SYSCLK divided by 256
	1111: SYSCLK divided by 512*/

	return (RCC_GetSYSCLCK() >> AHBPrescTable[(RCC->CFGR.Reg >> HPRE_BIT ) &HPRE_MASK ] );
 80006c8:	f7ff ffda 	bl	8000680 <RCC_GetSYSCLCK>
 80006cc:	4602      	mov	r2, r0
 80006ce:	4b05      	ldr	r3, [pc, #20]	; (80006e4 <RCC_GetHCLCK+0x20>)
 80006d0:	685b      	ldr	r3, [r3, #4]
 80006d2:	091b      	lsrs	r3, r3, #4
 80006d4:	f003 030f 	and.w	r3, r3, #15
 80006d8:	4903      	ldr	r1, [pc, #12]	; (80006e8 <RCC_GetHCLCK+0x24>)
 80006da:	5ccb      	ldrb	r3, [r1, r3]
 80006dc:	fa22 f303 	lsr.w	r3, r2, r3


}
 80006e0:	4618      	mov	r0, r3
 80006e2:	bd80      	pop	{r7, pc}
 80006e4:	40021000 	.word	0x40021000
 80006e8:	08000c04 	.word	0x08000c04

080006ec <RCC_GetPCLCK1>:
/**
 *
 * @return : PCLCK1 Frequency
 */
uint32_t RCC_GetPCLCK1(void)
{
 80006ec:	b580      	push	{r7, lr}
 80006ee:	af00      	add	r7, sp, #0
	100: HCLK divided by 2
	101: HCLK divided by 4
	110: HCLK divided by 8
	111: HCLK divided by 16	 */

	return (RCC_GetHCLCK() >> APBPrescTable[((RCC-> CFGR.Reg )>> PCLCK1_BIT )&PCLCK_MASK] );
 80006f0:	f7ff ffe8 	bl	80006c4 <RCC_GetHCLCK>
 80006f4:	4602      	mov	r2, r0
 80006f6:	4b05      	ldr	r3, [pc, #20]	; (800070c <RCC_GetPCLCK1+0x20>)
 80006f8:	685b      	ldr	r3, [r3, #4]
 80006fa:	0a1b      	lsrs	r3, r3, #8
 80006fc:	f003 0307 	and.w	r3, r3, #7
 8000700:	4903      	ldr	r1, [pc, #12]	; (8000710 <RCC_GetPCLCK1+0x24>)
 8000702:	5ccb      	ldrb	r3, [r1, r3]
 8000704:	fa22 f303 	lsr.w	r3, r2, r3

}
 8000708:	4618      	mov	r0, r3
 800070a:	bd80      	pop	{r7, pc}
 800070c:	40021000 	.word	0x40021000
 8000710:	08000bfc 	.word	0x08000bfc

08000714 <RCC_GetPCLCK2>:
/**
 *
 * @return : PCLCK2 Frequency
 */
uint32_t RCC_GetPCLCK2(void)
{
 8000714:	b580      	push	{r7, lr}
 8000716:	af00      	add	r7, sp, #0
	101: HCLK divided by 4
	110: HCLK divided by 8
	111: HCLK divided by 16*/


	return (RCC_GetHCLCK() >> APBPrescTable[((RCC-> CFGR.Reg )>> PCLCK2_BIT )&PCLCK_MASK] );
 8000718:	f7ff ffd4 	bl	80006c4 <RCC_GetHCLCK>
 800071c:	4602      	mov	r2, r0
 800071e:	4b05      	ldr	r3, [pc, #20]	; (8000734 <RCC_GetPCLCK2+0x20>)
 8000720:	685b      	ldr	r3, [r3, #4]
 8000722:	0adb      	lsrs	r3, r3, #11
 8000724:	f003 0307 	and.w	r3, r3, #7
 8000728:	4903      	ldr	r1, [pc, #12]	; (8000738 <RCC_GetPCLCK2+0x24>)
 800072a:	5ccb      	ldrb	r3, [r1, r3]
 800072c:	fa22 f303 	lsr.w	r3, r2, r3


}
 8000730:	4618      	mov	r0, r3
 8000732:	bd80      	pop	{r7, pc}
 8000734:	40021000 	.word	0x40021000
 8000738:	08000bfc 	.word	0x08000bfc

0800073c <USART_Init>:
 *
 * Return:	UART_ERR_Statue , Type:enum
 *
 ******************************************************************************/
UART_ERR_Statue USART_Init( USART_HandleTypeDef* Huart)
{
 800073c:	b580      	push	{r7, lr}
 800073e:	b086      	sub	sp, #24
 8000740:	af00      	add	r7, sp, #0
 8000742:	6078      	str	r0, [r7, #4]
	uint8_t LocalErrorStatue = NO_EROR;
 8000744:	2300      	movs	r3, #0
 8000746:	75fb      	strb	r3, [r7, #23]

	uint32_t LocalU32_PCLCKValue , LocalU32_BRRValue ;

	/*For Other Configuration*/
	Global_USART_CONFIG=Huart;
 8000748:	4a82      	ldr	r2, [pc, #520]	; (8000954 <USART_Init+0x218>)
 800074a:	687b      	ldr	r3, [r7, #4]
 800074c:	6013      	str	r3, [r2, #0]


	/*Enable RCC For USART*/
	switch (Huart->USART_SELECTION)
 800074e:	687b      	ldr	r3, [r7, #4]
 8000750:	781b      	ldrb	r3, [r3, #0]
 8000752:	2b02      	cmp	r3, #2
 8000754:	d014      	beq.n	8000780 <USART_Init+0x44>
 8000756:	2b02      	cmp	r3, #2
 8000758:	dc19      	bgt.n	800078e <USART_Init+0x52>
 800075a:	2b00      	cmp	r3, #0
 800075c:	d002      	beq.n	8000764 <USART_Init+0x28>
 800075e:	2b01      	cmp	r3, #1
 8000760:	d007      	beq.n	8000772 <USART_Init+0x36>
 8000762:	e014      	b.n	800078e <USART_Init+0x52>
	{
	case USART_ONE   : RCC_USART1_CLCK_EN() ; break;
 8000764:	4b7c      	ldr	r3, [pc, #496]	; (8000958 <USART_Init+0x21c>)
 8000766:	699b      	ldr	r3, [r3, #24]
 8000768:	4a7b      	ldr	r2, [pc, #492]	; (8000958 <USART_Init+0x21c>)
 800076a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800076e:	6193      	str	r3, [r2, #24]
 8000770:	e010      	b.n	8000794 <USART_Init+0x58>
	case USART_TWO   : RCC_USART2_CLCK_EN() ; break;
 8000772:	4b79      	ldr	r3, [pc, #484]	; (8000958 <USART_Init+0x21c>)
 8000774:	69db      	ldr	r3, [r3, #28]
 8000776:	4a78      	ldr	r2, [pc, #480]	; (8000958 <USART_Init+0x21c>)
 8000778:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800077c:	61d3      	str	r3, [r2, #28]
 800077e:	e009      	b.n	8000794 <USART_Init+0x58>
	case USART_THREE : RCC_USART3_CLCK_EN() ; break;
 8000780:	4b75      	ldr	r3, [pc, #468]	; (8000958 <USART_Init+0x21c>)
 8000782:	69db      	ldr	r3, [r3, #28]
 8000784:	4a74      	ldr	r2, [pc, #464]	; (8000958 <USART_Init+0x21c>)
 8000786:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800078a:	61d3      	str	r3, [r2, #28]
 800078c:	e002      	b.n	8000794 <USART_Init+0x58>
	default :  LocalErrorStatue = NOK ; break;
 800078e:	2301      	movs	r3, #1
 8000790:	75fb      	strb	r3, [r7, #23]
 8000792:	bf00      	nop
	When this bit is cleared the USART prescalers and outputs are stopped and the end of the
	current
	byte transfer in order to reduce power consumption. This bit is set and cleared by software.
	0: USART prescaler and outputs disabled
	1: USART enabled*/
	USART[Huart->USART_SELECTION]->CR1 |= (Huart->USART_STATUE);
 8000794:	687b      	ldr	r3, [r7, #4]
 8000796:	781b      	ldrb	r3, [r3, #0]
 8000798:	461a      	mov	r2, r3
 800079a:	4b70      	ldr	r3, [pc, #448]	; (800095c <USART_Init+0x220>)
 800079c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80007a0:	68da      	ldr	r2, [r3, #12]
 80007a2:	687b      	ldr	r3, [r7, #4]
 80007a4:	885b      	ldrh	r3, [r3, #2]
 80007a6:	4619      	mov	r1, r3
 80007a8:	687b      	ldr	r3, [r7, #4]
 80007aa:	781b      	ldrb	r3, [r3, #0]
 80007ac:	4618      	mov	r0, r3
 80007ae:	4b6b      	ldr	r3, [pc, #428]	; (800095c <USART_Init+0x220>)
 80007b0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80007b4:	430a      	orrs	r2, r1
 80007b6:	60da      	str	r2, [r3, #12]
		This bit enables the receiver. It is set and cleared by software.
		0: Receiver is disabled
		1: Receiver is enabled and begins searching for a start bit
	 */

	USART[Huart->USART_SELECTION]->CR1 |= (Huart->USART_MODE);
 80007b8:	687b      	ldr	r3, [r7, #4]
 80007ba:	781b      	ldrb	r3, [r3, #0]
 80007bc:	461a      	mov	r2, r3
 80007be:	4b67      	ldr	r3, [pc, #412]	; (800095c <USART_Init+0x220>)
 80007c0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80007c4:	68da      	ldr	r2, [r3, #12]
 80007c6:	687b      	ldr	r3, [r7, #4]
 80007c8:	791b      	ldrb	r3, [r3, #4]
 80007ca:	4619      	mov	r1, r3
 80007cc:	687b      	ldr	r3, [r7, #4]
 80007ce:	781b      	ldrb	r3, [r3, #0]
 80007d0:	4618      	mov	r0, r3
 80007d2:	4b62      	ldr	r3, [pc, #392]	; (800095c <USART_Init+0x220>)
 80007d4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80007d8:	430a      	orrs	r2, r1
 80007da:	60da      	str	r2, [r3, #12]
	This bit determines the word length. It is set or cleared by software.
	0: 1 Start bit, 8 Data bits, n Stop bit
	1: 1 Start bit, 9 Data bits, n Stop bit
	Note: The M bit must not be modified during a data transfer (both transmission and reception)*/

	USART[Huart->USART_SELECTION]->CR1 |= (Huart->USART_DATA_PAYLOAD) ;
 80007dc:	687b      	ldr	r3, [r7, #4]
 80007de:	781b      	ldrb	r3, [r3, #0]
 80007e0:	461a      	mov	r2, r3
 80007e2:	4b5e      	ldr	r3, [pc, #376]	; (800095c <USART_Init+0x220>)
 80007e4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80007e8:	68da      	ldr	r2, [r3, #12]
 80007ea:	687b      	ldr	r3, [r7, #4]
 80007ec:	88db      	ldrh	r3, [r3, #6]
 80007ee:	4619      	mov	r1, r3
 80007f0:	687b      	ldr	r3, [r7, #4]
 80007f2:	781b      	ldrb	r3, [r3, #0]
 80007f4:	4618      	mov	r0, r3
 80007f6:	4b59      	ldr	r3, [pc, #356]	; (800095c <USART_Init+0x220>)
 80007f8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80007fc:	430a      	orrs	r2, r1
 80007fe:	60da      	str	r2, [r3, #12]
	This bit selects the odd or even parity when the parity generation/detection is enabled (PCE
	bit set). It is set and cleared by software. The parity will be selected after the current byte.
	0: Even parity
	1: Odd parity   */

	USART[Huart->USART_SELECTION]->CR1 |= (Huart->PARITY) ;
 8000800:	687b      	ldr	r3, [r7, #4]
 8000802:	781b      	ldrb	r3, [r3, #0]
 8000804:	461a      	mov	r2, r3
 8000806:	4b55      	ldr	r3, [pc, #340]	; (800095c <USART_Init+0x220>)
 8000808:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800080c:	68da      	ldr	r2, [r3, #12]
 800080e:	687b      	ldr	r3, [r7, #4]
 8000810:	899b      	ldrh	r3, [r3, #12]
 8000812:	4619      	mov	r1, r3
 8000814:	687b      	ldr	r3, [r7, #4]
 8000816:	781b      	ldrb	r3, [r3, #0]
 8000818:	4618      	mov	r0, r3
 800081a:	4b50      	ldr	r3, [pc, #320]	; (800095c <USART_Init+0x220>)
 800081c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8000820:	430a      	orrs	r2, r1
 8000822:	60da      	str	r2, [r3, #12]
	01: 0.5 Stop bit
	10: 2 Stop bits
	11: 1.5 Stop bit
	The 0.5 Stop bit and 1.5 Stop bit are not available for UART4 & UART5.*/

	USART[Huart->USART_SELECTION]->CR2 |= (Huart->STOP_BITS) ;
 8000824:	687b      	ldr	r3, [r7, #4]
 8000826:	781b      	ldrb	r3, [r3, #0]
 8000828:	461a      	mov	r2, r3
 800082a:	4b4c      	ldr	r3, [pc, #304]	; (800095c <USART_Init+0x220>)
 800082c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000830:	691a      	ldr	r2, [r3, #16]
 8000832:	687b      	ldr	r3, [r7, #4]
 8000834:	89db      	ldrh	r3, [r3, #14]
 8000836:	4619      	mov	r1, r3
 8000838:	687b      	ldr	r3, [r7, #4]
 800083a:	781b      	ldrb	r3, [r3, #0]
 800083c:	4618      	mov	r0, r3
 800083e:	4b47      	ldr	r3, [pc, #284]	; (800095c <USART_Init+0x220>)
 8000840:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8000844:	430a      	orrs	r2, r1
 8000846:	611a      	str	r2, [r3, #16]
	1: RTS interrupt enabled, data is only requested when there is space in the receive buffer.
	The transmission of data is expected to cease after the current character has been
	transmitted. The RTS output is asserted (tied to 0) when a data can be received.
	This bit is not available for UART4 & UART5.*/

	USART[Huart->USART_SELECTION]->CR3 |= (Huart->HwFlowCtl) ;
 8000848:	687b      	ldr	r3, [r7, #4]
 800084a:	781b      	ldrb	r3, [r3, #0]
 800084c:	461a      	mov	r2, r3
 800084e:	4b43      	ldr	r3, [pc, #268]	; (800095c <USART_Init+0x220>)
 8000850:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000854:	695a      	ldr	r2, [r3, #20]
 8000856:	687b      	ldr	r3, [r7, #4]
 8000858:	8a1b      	ldrh	r3, [r3, #16]
 800085a:	4619      	mov	r1, r3
 800085c:	687b      	ldr	r3, [r7, #4]
 800085e:	781b      	ldrb	r3, [r3, #0]
 8000860:	4618      	mov	r0, r3
 8000862:	4b3e      	ldr	r3, [pc, #248]	; (800095c <USART_Init+0x220>)
 8000864:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8000868:	430a      	orrs	r2, r1
 800086a:	615a      	str	r2, [r3, #20]
	/*Switch USART TO Switch PCLCK*/
	/**
	 * USART1 		   --> PCLCK2
	 * USART2 | USART3 --> PCLCK1
	 */
	switch (Huart->USART_SELECTION)
 800086c:	687b      	ldr	r3, [r7, #4]
 800086e:	781b      	ldrb	r3, [r3, #0]
 8000870:	2b02      	cmp	r3, #2
 8000872:	d01a      	beq.n	80008aa <USART_Init+0x16e>
 8000874:	2b02      	cmp	r3, #2
 8000876:	dc22      	bgt.n	80008be <USART_Init+0x182>
 8000878:	2b00      	cmp	r3, #0
 800087a:	d002      	beq.n	8000882 <USART_Init+0x146>
 800087c:	2b01      	cmp	r3, #1
 800087e:	d00a      	beq.n	8000896 <USART_Init+0x15a>
 8000880:	e01d      	b.n	80008be <USART_Init+0x182>
	{
	case USART_ONE   :     RCC_USART1_CLCK_EN();
 8000882:	4b35      	ldr	r3, [pc, #212]	; (8000958 <USART_Init+0x21c>)
 8000884:	699b      	ldr	r3, [r3, #24]
 8000886:	4a34      	ldr	r2, [pc, #208]	; (8000958 <USART_Init+0x21c>)
 8000888:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800088c:	6193      	str	r3, [r2, #24]
	LocalU32_PCLCKValue = RCC_GetPCLCK2()    ;break;
 800088e:	f7ff ff41 	bl	8000714 <RCC_GetPCLCK2>
 8000892:	6138      	str	r0, [r7, #16]
 8000894:	e016      	b.n	80008c4 <USART_Init+0x188>
	case USART_TWO   :     RCC_USART2_CLCK_EN();
 8000896:	4b30      	ldr	r3, [pc, #192]	; (8000958 <USART_Init+0x21c>)
 8000898:	69db      	ldr	r3, [r3, #28]
 800089a:	4a2f      	ldr	r2, [pc, #188]	; (8000958 <USART_Init+0x21c>)
 800089c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80008a0:	61d3      	str	r3, [r2, #28]
	LocalU32_PCLCKValue = RCC_GetPCLCK1();   ;break;
 80008a2:	f7ff ff23 	bl	80006ec <RCC_GetPCLCK1>
 80008a6:	6138      	str	r0, [r7, #16]
 80008a8:	e00c      	b.n	80008c4 <USART_Init+0x188>
	case USART_THREE :     RCC_USART3_CLCK_EN();
 80008aa:	4b2b      	ldr	r3, [pc, #172]	; (8000958 <USART_Init+0x21c>)
 80008ac:	69db      	ldr	r3, [r3, #28]
 80008ae:	4a2a      	ldr	r2, [pc, #168]	; (8000958 <USART_Init+0x21c>)
 80008b0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80008b4:	61d3      	str	r3, [r2, #28]
	LocalU32_PCLCKValue = RCC_GetPCLCK1();   ;break;
 80008b6:	f7ff ff19 	bl	80006ec <RCC_GetPCLCK1>
 80008ba:	6138      	str	r0, [r7, #16]
 80008bc:	e002      	b.n	80008c4 <USART_Init+0x188>
	default :  LocalErrorStatue = NOK ; break;
 80008be:	2301      	movs	r3, #1
 80008c0:	75fb      	strb	r3, [r7, #23]
 80008c2:	bf00      	nop
	}


	LocalU32_BRRValue = UART_BRR_Register(LocalU32_PCLCKValue ,Huart->BAUDRATE );
 80008c4:	687b      	ldr	r3, [r7, #4]
 80008c6:	689b      	ldr	r3, [r3, #8]
 80008c8:	011b      	lsls	r3, r3, #4
 80008ca:	693a      	ldr	r2, [r7, #16]
 80008cc:	fbb2 f3f3 	udiv	r3, r2, r3
 80008d0:	0119      	lsls	r1, r3, #4
 80008d2:	693a      	ldr	r2, [r7, #16]
 80008d4:	4613      	mov	r3, r2
 80008d6:	009b      	lsls	r3, r3, #2
 80008d8:	4413      	add	r3, r2
 80008da:	009a      	lsls	r2, r3, #2
 80008dc:	441a      	add	r2, r3
 80008de:	687b      	ldr	r3, [r7, #4]
 80008e0:	689b      	ldr	r3, [r3, #8]
 80008e2:	009b      	lsls	r3, r3, #2
 80008e4:	fbb2 f2f3 	udiv	r2, r2, r3
 80008e8:	687b      	ldr	r3, [r7, #4]
 80008ea:	689b      	ldr	r3, [r3, #8]
 80008ec:	011b      	lsls	r3, r3, #4
 80008ee:	6938      	ldr	r0, [r7, #16]
 80008f0:	fbb0 f3f3 	udiv	r3, r0, r3
 80008f4:	2064      	movs	r0, #100	; 0x64
 80008f6:	fb00 f303 	mul.w	r3, r0, r3
 80008fa:	1ad3      	subs	r3, r2, r3
 80008fc:	011b      	lsls	r3, r3, #4
 80008fe:	4a18      	ldr	r2, [pc, #96]	; (8000960 <USART_Init+0x224>)
 8000900:	fba2 2303 	umull	r2, r3, r2, r3
 8000904:	095b      	lsrs	r3, r3, #5
 8000906:	f003 030f 	and.w	r3, r3, #15
 800090a:	430b      	orrs	r3, r1
 800090c:	60fb      	str	r3, [r7, #12]

	USART[Huart->USART_SELECTION]->BRR = LocalU32_BRRValue ;
 800090e:	687b      	ldr	r3, [r7, #4]
 8000910:	781b      	ldrb	r3, [r3, #0]
 8000912:	461a      	mov	r2, r3
 8000914:	4b11      	ldr	r3, [pc, #68]	; (800095c <USART_Init+0x220>)
 8000916:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800091a:	68fa      	ldr	r2, [r7, #12]
 800091c:	609a      	str	r2, [r3, #8]


	/************************ Interrupt **************************/

	if(Huart->IRQ_USART_Enable !=USART_IRQ_Enable_NONE )
 800091e:	687b      	ldr	r3, [r7, #4]
 8000920:	8a5b      	ldrh	r3, [r3, #18]
 8000922:	2b00      	cmp	r3, #0
 8000924:	d011      	beq.n	800094a <USART_Init+0x20e>
	{

		USART[Huart->USART_SELECTION]->CR1 |= (Huart->IRQ_USART_Enable );
 8000926:	687b      	ldr	r3, [r7, #4]
 8000928:	781b      	ldrb	r3, [r3, #0]
 800092a:	461a      	mov	r2, r3
 800092c:	4b0b      	ldr	r3, [pc, #44]	; (800095c <USART_Init+0x220>)
 800092e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000932:	68da      	ldr	r2, [r3, #12]
 8000934:	687b      	ldr	r3, [r7, #4]
 8000936:	8a5b      	ldrh	r3, [r3, #18]
 8000938:	4619      	mov	r1, r3
 800093a:	687b      	ldr	r3, [r7, #4]
 800093c:	781b      	ldrb	r3, [r3, #0]
 800093e:	4618      	mov	r0, r3
 8000940:	4b06      	ldr	r3, [pc, #24]	; (800095c <USART_Init+0x220>)
 8000942:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8000946:	430a      	orrs	r2, r1
 8000948:	60da      	str	r2, [r3, #12]
	{
		/*unable Interrupt*/
	}


	return LocalErrorStatue ;
 800094a:	7dfb      	ldrb	r3, [r7, #23]

}
 800094c:	4618      	mov	r0, r3
 800094e:	3718      	adds	r7, #24
 8000950:	46bd      	mov	sp, r7
 8000952:	bd80      	pop	{r7, pc}
 8000954:	20000084 	.word	0x20000084
 8000958:	40021000 	.word	0x40021000
 800095c:	2000001c 	.word	0x2000001c
 8000960:	51eb851f 	.word	0x51eb851f

08000964 <USART_U16SendData>:
 *
 * Return:	UART_ERR_Statue , Type:enum
 *
 ******************************************************************************/
UART_ERR_Statue USART_U16SendData( USART_TypeDef_S* Huart, uint16_t *PTxBuffre ,USART_Polling_Mechanism_E Polling_Status)
{
 8000964:	b480      	push	{r7}
 8000966:	b087      	sub	sp, #28
 8000968:	af00      	add	r7, sp, #0
 800096a:	60f8      	str	r0, [r7, #12]
 800096c:	60b9      	str	r1, [r7, #8]
 800096e:	4613      	mov	r3, r2
 8000970:	71fb      	strb	r3, [r7, #7]
	uint8_t LocalErrorStatue = NO_EROR;
 8000972:	2300      	movs	r3, #0
 8000974:	75fb      	strb	r3, [r7, #23]

	/*wait until make sure TXE =1 --> Empty (with pooling mechanism)*/
	/* Write the data to send in the USART_DR register (this clears the TXE bit). Repeat this
	 * for each data to be transmitted in case of single buffer */
	if(Polling_Status == USART_POLLING_ENABLE)
 8000976:	79fb      	ldrb	r3, [r7, #7]
 8000978:	2b01      	cmp	r3, #1
 800097a:	d106      	bne.n	800098a <USART_U16SendData+0x26>
	{
		/*Polling in TXE Bit*/
		while(! (Huart->SR & 1<<TXE_BIT));
 800097c:	bf00      	nop
 800097e:	68fb      	ldr	r3, [r7, #12]
 8000980:	681b      	ldr	r3, [r3, #0]
 8000982:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000986:	2b00      	cmp	r3, #0
 8000988:	d0f9      	beq.n	800097e <USART_U16SendData+0x1a>
	When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register),
	the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect
	because it is replaced by the parity.
	When receiving with the parity enabled, the value read in the MSB bit is the received parity
	bit.*/
	if(Global_USART_CONFIG->USART_DATA_PAYLOAD == USART_9DATA_BITS)
 800098a:	4b0e      	ldr	r3, [pc, #56]	; (80009c4 <USART_U16SendData+0x60>)
 800098c:	681b      	ldr	r3, [r3, #0]
 800098e:	88db      	ldrh	r3, [r3, #6]
 8000990:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8000994:	d106      	bne.n	80009a4 <USART_U16SendData+0x40>
	{
		/*ignore the nine bit of Date Configured as parity*/
		Huart->DR =(*PTxBuffre & (uint16_t)0x01FF);
 8000996:	68bb      	ldr	r3, [r7, #8]
 8000998:	881b      	ldrh	r3, [r3, #0]
 800099a:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800099e:	68fb      	ldr	r3, [r7, #12]
 80009a0:	605a      	str	r2, [r3, #4]
 80009a2:	e009      	b.n	80009b8 <USART_U16SendData+0x54>

	}
	else if (Global_USART_CONFIG->USART_DATA_PAYLOAD == USART_8DATA_BITS)
 80009a4:	4b07      	ldr	r3, [pc, #28]	; (80009c4 <USART_U16SendData+0x60>)
 80009a6:	681b      	ldr	r3, [r3, #0]
 80009a8:	88db      	ldrh	r3, [r3, #6]
 80009aa:	2b00      	cmp	r3, #0
 80009ac:	d104      	bne.n	80009b8 <USART_U16SendData+0x54>
	{
		/*ignore the eight bit of Date Configured as parity*/
		Huart->DR =(*PTxBuffre & (uint8_t)0xFF);
 80009ae:	68bb      	ldr	r3, [r7, #8]
 80009b0:	881b      	ldrh	r3, [r3, #0]
 80009b2:	b2da      	uxtb	r2, r3
 80009b4:	68fb      	ldr	r3, [r7, #12]
 80009b6:	605a      	str	r2, [r3, #4]

	}


	return LocalErrorStatue ;
 80009b8:	7dfb      	ldrb	r3, [r7, #23]
}
 80009ba:	4618      	mov	r0, r3
 80009bc:	371c      	adds	r7, #28
 80009be:	46bd      	mov	sp, r7
 80009c0:	bc80      	pop	{r7}
 80009c2:	4770      	bx	lr
 80009c4:	20000084 	.word	0x20000084

080009c8 <USART_U16RecieveData>:
 *
 * Return:	UART_ERR_Statue , Type:enum
 *
 ******************************************************************************/
UART_ERR_Statue USART_U16RecieveData( USART_TypeDef_S* Huart, uint16_t* PRxBuffre ,USART_Polling_Mechanism_E Polling_Status)
{
 80009c8:	b480      	push	{r7}
 80009ca:	b087      	sub	sp, #28
 80009cc:	af00      	add	r7, sp, #0
 80009ce:	60f8      	str	r0, [r7, #12]
 80009d0:	60b9      	str	r1, [r7, #8]
 80009d2:	4613      	mov	r3, r2
 80009d4:	71fb      	strb	r3, [r7, #7]
	uint8_t LocalErrorStatue = NO_EROR;
 80009d6:	2300      	movs	r3, #0
 80009d8:	75fb      	strb	r3, [r7, #23]
	 The RXNE bit is set. It indicates that the content of the shift register is transferred to the
	RDR. In other words, data has been received and can be read (as well as its
	associated error flags).*/


	if(Polling_Status ==USART_POLLING_ENABLE)
 80009da:	79fb      	ldrb	r3, [r7, #7]
 80009dc:	2b01      	cmp	r3, #1
 80009de:	d106      	bne.n	80009ee <USART_U16RecieveData+0x26>
			It is cleared by a read to the USART_DR register. The RXNE flag can also be cleared by
			writing a zero to it. This clearing sequence is recommended only for multibuffer
			communication.
			0: Data is not received
			1: Received data is ready to be read.*/
	while( !(Huart->SR & 1<< RXNE_BIT ));
 80009e0:	bf00      	nop
 80009e2:	68fb      	ldr	r3, [r7, #12]
 80009e4:	681b      	ldr	r3, [r3, #0]
 80009e6:	f003 0320 	and.w	r3, r3, #32
 80009ea:	2b00      	cmp	r3, #0
 80009ec:	d0f9      	beq.n	80009e2 <USART_U16RecieveData+0x1a>


	}

	if(Global_USART_CONFIG->USART_DATA_PAYLOAD == USART_9DATA_BITS)
 80009ee:	4b1c      	ldr	r3, [pc, #112]	; (8000a60 <USART_U16RecieveData+0x98>)
 80009f0:	681b      	ldr	r3, [r3, #0]
 80009f2:	88db      	ldrh	r3, [r3, #6]
 80009f4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80009f8:	d112      	bne.n	8000a20 <USART_U16RecieveData+0x58>
	{

		if(Global_USART_CONFIG->PARITY ==USART_NO_PARITY )
 80009fa:	4b19      	ldr	r3, [pc, #100]	; (8000a60 <USART_U16RecieveData+0x98>)
 80009fc:	681b      	ldr	r3, [r3, #0]
 80009fe:	899b      	ldrh	r3, [r3, #12]
 8000a00:	2b00      	cmp	r3, #0
 8000a02:	d105      	bne.n	8000a10 <USART_U16RecieveData+0x48>
		{

			*((uint16_t*)PRxBuffre)=Huart->DR ;
 8000a04:	68fb      	ldr	r3, [r7, #12]
 8000a06:	685b      	ldr	r3, [r3, #4]
 8000a08:	b29a      	uxth	r2, r3
 8000a0a:	68bb      	ldr	r3, [r7, #8]
 8000a0c:	801a      	strh	r2, [r3, #0]
 8000a0e:	e021      	b.n	8000a54 <USART_U16RecieveData+0x8c>


		}
		else
		{
			*((uint16_t*)PRxBuffre)=( Huart->DR & (uint8_t)0xFF) ;
 8000a10:	68fb      	ldr	r3, [r7, #12]
 8000a12:	685b      	ldr	r3, [r3, #4]
 8000a14:	b29b      	uxth	r3, r3
 8000a16:	b2db      	uxtb	r3, r3
 8000a18:	b29a      	uxth	r2, r3
 8000a1a:	68bb      	ldr	r3, [r7, #8]
 8000a1c:	801a      	strh	r2, [r3, #0]
 8000a1e:	e019      	b.n	8000a54 <USART_U16RecieveData+0x8c>

		}


	}
	else if (Global_USART_CONFIG->USART_DATA_PAYLOAD == USART_8DATA_BITS)
 8000a20:	4b0f      	ldr	r3, [pc, #60]	; (8000a60 <USART_U16RecieveData+0x98>)
 8000a22:	681b      	ldr	r3, [r3, #0]
 8000a24:	88db      	ldrh	r3, [r3, #6]
 8000a26:	2b00      	cmp	r3, #0
 8000a28:	d114      	bne.n	8000a54 <USART_U16RecieveData+0x8c>
	{

		if(Global_USART_CONFIG->PARITY ==USART_NO_PARITY )
 8000a2a:	4b0d      	ldr	r3, [pc, #52]	; (8000a60 <USART_U16RecieveData+0x98>)
 8000a2c:	681b      	ldr	r3, [r3, #0]
 8000a2e:	899b      	ldrh	r3, [r3, #12]
 8000a30:	2b00      	cmp	r3, #0
 8000a32:	d107      	bne.n	8000a44 <USART_U16RecieveData+0x7c>
		{

			//no parity So all 8bit are considered data
			*((uint16_t*) PRxBuffre) = ( Huart->DR  & (uint8_t)0xFF ) ;
 8000a34:	68fb      	ldr	r3, [r7, #12]
 8000a36:	685b      	ldr	r3, [r3, #4]
 8000a38:	b29b      	uxth	r3, r3
 8000a3a:	b2db      	uxtb	r3, r3
 8000a3c:	b29a      	uxth	r2, r3
 8000a3e:	68bb      	ldr	r3, [r7, #8]
 8000a40:	801a      	strh	r2, [r3, #0]
 8000a42:	e007      	b.n	8000a54 <USART_U16RecieveData+0x8c>
		}
		else
		{
			//Parity is used, so,7 bits will be of user data and 1 bit is parity
			*((uint16_t*) PRxBuffre) = ( Huart->DR  & (uint8_t)0X7F );
 8000a44:	68fb      	ldr	r3, [r7, #12]
 8000a46:	685b      	ldr	r3, [r3, #4]
 8000a48:	b29b      	uxth	r3, r3
 8000a4a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8000a4e:	b29a      	uxth	r2, r3
 8000a50:	68bb      	ldr	r3, [r7, #8]
 8000a52:	801a      	strh	r2, [r3, #0]
	}




	return LocalErrorStatue ;
 8000a54:	7dfb      	ldrb	r3, [r7, #23]
}
 8000a56:	4618      	mov	r0, r3
 8000a58:	371c      	adds	r7, #28
 8000a5a:	46bd      	mov	sp, r7
 8000a5c:	bc80      	pop	{r7}
 8000a5e:	4770      	bx	lr
 8000a60:	20000084 	.word	0x20000084

08000a64 <main>:
void CLCK_Init();
void GPIO_Init();


int main(void)
{
 8000a64:	b5b0      	push	{r4, r5, r7, lr}
 8000a66:	b086      	sub	sp, #24
 8000a68:	af00      	add	r7, sp, #0

	CLCK_Init();
 8000a6a:	f000 f81f 	bl	8000aac <CLCK_Init>
	GPIO_Init();
 8000a6e:	f000 f837 	bl	8000ae0 <GPIO_Init>


	USART_HandleTypeDef USART1CFG=
 8000a72:	4b0c      	ldr	r3, [pc, #48]	; (8000aa4 <main+0x40>)
 8000a74:	1d3c      	adds	r4, r7, #4
 8000a76:	461d      	mov	r5, r3
 8000a78:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000a7a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000a7c:	682b      	ldr	r3, [r5, #0]
 8000a7e:	6023      	str	r3, [r4, #0]
				.USART_STATUE=USART_ENABLE,
				.HwFlowCtl=USART_HwFlowCtl_NONE,

		};

		USART_Init(&USART1CFG);
 8000a80:	1d3b      	adds	r3, r7, #4
 8000a82:	4618      	mov	r0, r3
 8000a84:	f7ff fe5a 	bl	800073c <USART_Init>
	uint16_t CH ;


while(1)
{
	USART_U16RecieveData(USART1, &CH, USART_POLLING_ENABLE);
 8000a88:	1cbb      	adds	r3, r7, #2
 8000a8a:	2201      	movs	r2, #1
 8000a8c:	4619      	mov	r1, r3
 8000a8e:	4806      	ldr	r0, [pc, #24]	; (8000aa8 <main+0x44>)
 8000a90:	f7ff ff9a 	bl	80009c8 <USART_U16RecieveData>

	USART_U16SendData(USART1, &CH, USART_POLLING_ENABLE);
 8000a94:	1cbb      	adds	r3, r7, #2
 8000a96:	2201      	movs	r2, #1
 8000a98:	4619      	mov	r1, r3
 8000a9a:	4803      	ldr	r0, [pc, #12]	; (8000aa8 <main+0x44>)
 8000a9c:	f7ff ff62 	bl	8000964 <USART_U16SendData>
	USART_U16RecieveData(USART1, &CH, USART_POLLING_ENABLE);
 8000aa0:	e7f2      	b.n	8000a88 <main+0x24>
 8000aa2:	bf00      	nop
 8000aa4:	08000be8 	.word	0x08000be8
 8000aa8:	40013800 	.word	0x40013800

08000aac <CLCK_Init>:
	for(;;);

}

void CLCK_Init()
{
 8000aac:	b480      	push	{r7}
 8000aae:	af00      	add	r7, sp, #0

	RCC_GPIOA_CLCK_EN();
 8000ab0:	4b0a      	ldr	r3, [pc, #40]	; (8000adc <CLCK_Init+0x30>)
 8000ab2:	699b      	ldr	r3, [r3, #24]
 8000ab4:	4a09      	ldr	r2, [pc, #36]	; (8000adc <CLCK_Init+0x30>)
 8000ab6:	f043 0304 	orr.w	r3, r3, #4
 8000aba:	6193      	str	r3, [r2, #24]
	RCC_GPIOB_CLCK_EN();
 8000abc:	4b07      	ldr	r3, [pc, #28]	; (8000adc <CLCK_Init+0x30>)
 8000abe:	699b      	ldr	r3, [r3, #24]
 8000ac0:	4a06      	ldr	r2, [pc, #24]	; (8000adc <CLCK_Init+0x30>)
 8000ac2:	f043 0308 	orr.w	r3, r3, #8
 8000ac6:	6193      	str	r3, [r2, #24]
	AFIO_GPIOA_CLCK_EN();
 8000ac8:	4b04      	ldr	r3, [pc, #16]	; (8000adc <CLCK_Init+0x30>)
 8000aca:	699b      	ldr	r3, [r3, #24]
 8000acc:	4a03      	ldr	r2, [pc, #12]	; (8000adc <CLCK_Init+0x30>)
 8000ace:	f043 0301 	orr.w	r3, r3, #1
 8000ad2:	6193      	str	r3, [r2, #24]



}
 8000ad4:	bf00      	nop
 8000ad6:	46bd      	mov	sp, r7
 8000ad8:	bc80      	pop	{r7}
 8000ada:	4770      	bx	lr
 8000adc:	40021000 	.word	0x40021000

08000ae0 <GPIO_Init>:
void GPIO_Init()
{
 8000ae0:	b580      	push	{r7, lr}
 8000ae2:	b086      	sub	sp, #24
 8000ae4:	af00      	add	r7, sp, #0
	uint8_t counter ;
	GPIO_PinConfig_S GPIO_PIN[2]=
 8000ae6:	1d3b      	adds	r3, r7, #4
 8000ae8:	2200      	movs	r2, #0
 8000aea:	601a      	str	r2, [r3, #0]
 8000aec:	605a      	str	r2, [r3, #4]
 8000aee:	609a      	str	r2, [r3, #8]
 8000af0:	60da      	str	r2, [r3, #12]
 8000af2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000af6:	80fb      	strh	r3, [r7, #6]
 8000af8:	2306      	movs	r3, #6
 8000afa:	723b      	strb	r3, [r7, #8]
 8000afc:	2302      	movs	r3, #2
 8000afe:	727b      	strb	r3, [r7, #9]
 8000b00:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000b04:	81fb      	strh	r3, [r7, #14]
 8000b06:	2308      	movs	r3, #8
 8000b08:	743b      	strb	r3, [r7, #16]

			}

	};

	for(counter = 0 ; counter < 2 ; counter++)
 8000b0a:	2300      	movs	r3, #0
 8000b0c:	75fb      	strb	r3, [r7, #23]
 8000b0e:	e009      	b.n	8000b24 <GPIO_Init+0x44>
	{
		GPIO_u8PinInit(&GPIO_PIN[counter]);
 8000b10:	7dfb      	ldrb	r3, [r7, #23]
 8000b12:	1d3a      	adds	r2, r7, #4
 8000b14:	00db      	lsls	r3, r3, #3
 8000b16:	4413      	add	r3, r2
 8000b18:	4618      	mov	r0, r3
 8000b1a:	f7ff fcff 	bl	800051c <GPIO_u8PinInit>
	for(counter = 0 ; counter < 2 ; counter++)
 8000b1e:	7dfb      	ldrb	r3, [r7, #23]
 8000b20:	3301      	adds	r3, #1
 8000b22:	75fb      	strb	r3, [r7, #23]
 8000b24:	7dfb      	ldrb	r3, [r7, #23]
 8000b26:	2b01      	cmp	r3, #1
 8000b28:	d9f2      	bls.n	8000b10 <GPIO_Init+0x30>
	}


}
 8000b2a:	bf00      	nop
 8000b2c:	bf00      	nop
 8000b2e:	3718      	adds	r7, #24
 8000b30:	46bd      	mov	sp, r7
 8000b32:	bd80      	pop	{r7, pc}

08000b34 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000b34:	480d      	ldr	r0, [pc, #52]	; (8000b6c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000b36:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8000b38:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000b3c:	480c      	ldr	r0, [pc, #48]	; (8000b70 <LoopForever+0x6>)
  ldr r1, =_edata
 8000b3e:	490d      	ldr	r1, [pc, #52]	; (8000b74 <LoopForever+0xa>)
  ldr r2, =_sidata
 8000b40:	4a0d      	ldr	r2, [pc, #52]	; (8000b78 <LoopForever+0xe>)
  movs r3, #0
 8000b42:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000b44:	e002      	b.n	8000b4c <LoopCopyDataInit>

08000b46 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000b46:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000b48:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000b4a:	3304      	adds	r3, #4

08000b4c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000b4c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000b4e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000b50:	d3f9      	bcc.n	8000b46 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000b52:	4a0a      	ldr	r2, [pc, #40]	; (8000b7c <LoopForever+0x12>)
  ldr r4, =_ebss
 8000b54:	4c0a      	ldr	r4, [pc, #40]	; (8000b80 <LoopForever+0x16>)
  movs r3, #0
 8000b56:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000b58:	e001      	b.n	8000b5e <LoopFillZerobss>

08000b5a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000b5a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000b5c:	3204      	adds	r2, #4

08000b5e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000b5e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000b60:	d3fb      	bcc.n	8000b5a <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8000b62:	f000 f811 	bl	8000b88 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8000b66:	f7ff ff7d 	bl	8000a64 <main>

08000b6a <LoopForever>:

LoopForever:
  b LoopForever
 8000b6a:	e7fe      	b.n	8000b6a <LoopForever>
  ldr   r0, =_estack
 8000b6c:	20002800 	.word	0x20002800
  ldr r0, =_sdata
 8000b70:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000b74:	20000028 	.word	0x20000028
  ldr r2, =_sidata
 8000b78:	08000c1c 	.word	0x08000c1c
  ldr r2, =_sbss
 8000b7c:	20000028 	.word	0x20000028
  ldr r4, =_ebss
 8000b80:	20000088 	.word	0x20000088

08000b84 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000b84:	e7fe      	b.n	8000b84 <ADC1_2_IRQHandler>
	...

08000b88 <__libc_init_array>:
 8000b88:	b570      	push	{r4, r5, r6, lr}
 8000b8a:	2600      	movs	r6, #0
 8000b8c:	4d0c      	ldr	r5, [pc, #48]	; (8000bc0 <__libc_init_array+0x38>)
 8000b8e:	4c0d      	ldr	r4, [pc, #52]	; (8000bc4 <__libc_init_array+0x3c>)
 8000b90:	1b64      	subs	r4, r4, r5
 8000b92:	10a4      	asrs	r4, r4, #2
 8000b94:	42a6      	cmp	r6, r4
 8000b96:	d109      	bne.n	8000bac <__libc_init_array+0x24>
 8000b98:	f000 f81a 	bl	8000bd0 <_init>
 8000b9c:	2600      	movs	r6, #0
 8000b9e:	4d0a      	ldr	r5, [pc, #40]	; (8000bc8 <__libc_init_array+0x40>)
 8000ba0:	4c0a      	ldr	r4, [pc, #40]	; (8000bcc <__libc_init_array+0x44>)
 8000ba2:	1b64      	subs	r4, r4, r5
 8000ba4:	10a4      	asrs	r4, r4, #2
 8000ba6:	42a6      	cmp	r6, r4
 8000ba8:	d105      	bne.n	8000bb6 <__libc_init_array+0x2e>
 8000baa:	bd70      	pop	{r4, r5, r6, pc}
 8000bac:	f855 3b04 	ldr.w	r3, [r5], #4
 8000bb0:	4798      	blx	r3
 8000bb2:	3601      	adds	r6, #1
 8000bb4:	e7ee      	b.n	8000b94 <__libc_init_array+0xc>
 8000bb6:	f855 3b04 	ldr.w	r3, [r5], #4
 8000bba:	4798      	blx	r3
 8000bbc:	3601      	adds	r6, #1
 8000bbe:	e7f2      	b.n	8000ba6 <__libc_init_array+0x1e>
 8000bc0:	08000c14 	.word	0x08000c14
 8000bc4:	08000c14 	.word	0x08000c14
 8000bc8:	08000c14 	.word	0x08000c14
 8000bcc:	08000c18 	.word	0x08000c18

08000bd0 <_init>:
 8000bd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000bd2:	bf00      	nop
 8000bd4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000bd6:	bc08      	pop	{r3}
 8000bd8:	469e      	mov	lr, r3
 8000bda:	4770      	bx	lr

08000bdc <_fini>:
 8000bdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000bde:	bf00      	nop
 8000be0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000be2:	bc08      	pop	{r3}
 8000be4:	469e      	mov	lr, r3
 8000be6:	4770      	bx	lr
